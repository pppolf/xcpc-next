
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Balloon` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Balloon
 * 
 */
export type BalloonModel = runtime.Types.Result.DefaultSelection<Prisma.$BalloonPayload>

export type AggregateBalloon = {
  _count: BalloonCountAggregateOutputType | null
  _avg: BalloonAvgAggregateOutputType | null
  _sum: BalloonSumAggregateOutputType | null
  _min: BalloonMinAggregateOutputType | null
  _max: BalloonMaxAggregateOutputType | null
}

export type BalloonAvgAggregateOutputType = {
  id: number | null
  contestId: number | null
}

export type BalloonSumAggregateOutputType = {
  id: number | null
  contestId: number | null
}

export type BalloonMinAggregateOutputType = {
  id: number | null
  submissionId: string | null
  contestId: number | null
  status: string | null
  assignedToId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type BalloonMaxAggregateOutputType = {
  id: number | null
  submissionId: string | null
  contestId: number | null
  status: string | null
  assignedToId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type BalloonCountAggregateOutputType = {
  id: number
  submissionId: number
  contestId: number
  status: number
  assignedToId: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type BalloonAvgAggregateInputType = {
  id?: true
  contestId?: true
}

export type BalloonSumAggregateInputType = {
  id?: true
  contestId?: true
}

export type BalloonMinAggregateInputType = {
  id?: true
  submissionId?: true
  contestId?: true
  status?: true
  assignedToId?: true
  createdAt?: true
  updatedAt?: true
}

export type BalloonMaxAggregateInputType = {
  id?: true
  submissionId?: true
  contestId?: true
  status?: true
  assignedToId?: true
  createdAt?: true
  updatedAt?: true
}

export type BalloonCountAggregateInputType = {
  id?: true
  submissionId?: true
  contestId?: true
  status?: true
  assignedToId?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type BalloonAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Balloon to aggregate.
   */
  where?: Prisma.BalloonWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Balloons to fetch.
   */
  orderBy?: Prisma.BalloonOrderByWithRelationInput | Prisma.BalloonOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.BalloonWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Balloons from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Balloons.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Balloons
  **/
  _count?: true | BalloonCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: BalloonAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: BalloonSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: BalloonMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: BalloonMaxAggregateInputType
}

export type GetBalloonAggregateType<T extends BalloonAggregateArgs> = {
      [P in keyof T & keyof AggregateBalloon]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateBalloon[P]>
    : Prisma.GetScalarType<T[P], AggregateBalloon[P]>
}




export type BalloonGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.BalloonWhereInput
  orderBy?: Prisma.BalloonOrderByWithAggregationInput | Prisma.BalloonOrderByWithAggregationInput[]
  by: Prisma.BalloonScalarFieldEnum[] | Prisma.BalloonScalarFieldEnum
  having?: Prisma.BalloonScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: BalloonCountAggregateInputType | true
  _avg?: BalloonAvgAggregateInputType
  _sum?: BalloonSumAggregateInputType
  _min?: BalloonMinAggregateInputType
  _max?: BalloonMaxAggregateInputType
}

export type BalloonGroupByOutputType = {
  id: number
  submissionId: string
  contestId: number
  status: string
  assignedToId: string | null
  createdAt: Date
  updatedAt: Date
  _count: BalloonCountAggregateOutputType | null
  _avg: BalloonAvgAggregateOutputType | null
  _sum: BalloonSumAggregateOutputType | null
  _min: BalloonMinAggregateOutputType | null
  _max: BalloonMaxAggregateOutputType | null
}

type GetBalloonGroupByPayload<T extends BalloonGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<BalloonGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof BalloonGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], BalloonGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], BalloonGroupByOutputType[P]>
      }
    >
  >



export type BalloonWhereInput = {
  AND?: Prisma.BalloonWhereInput | Prisma.BalloonWhereInput[]
  OR?: Prisma.BalloonWhereInput[]
  NOT?: Prisma.BalloonWhereInput | Prisma.BalloonWhereInput[]
  id?: Prisma.IntFilter<"Balloon"> | number
  submissionId?: Prisma.StringFilter<"Balloon"> | string
  contestId?: Prisma.IntFilter<"Balloon"> | number
  status?: Prisma.StringFilter<"Balloon"> | string
  assignedToId?: Prisma.StringNullableFilter<"Balloon"> | string | null
  createdAt?: Prisma.DateTimeFilter<"Balloon"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Balloon"> | Date | string
  submission?: Prisma.XOR<Prisma.SubmissionScalarRelationFilter, Prisma.SubmissionWhereInput>
  contest?: Prisma.XOR<Prisma.ContestScalarRelationFilter, Prisma.ContestWhereInput>
  assignedTo?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}

export type BalloonOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  submissionId?: Prisma.SortOrder
  contestId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  assignedToId?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  submission?: Prisma.SubmissionOrderByWithRelationInput
  contest?: Prisma.ContestOrderByWithRelationInput
  assignedTo?: Prisma.UserOrderByWithRelationInput
}

export type BalloonWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  submissionId?: string
  AND?: Prisma.BalloonWhereInput | Prisma.BalloonWhereInput[]
  OR?: Prisma.BalloonWhereInput[]
  NOT?: Prisma.BalloonWhereInput | Prisma.BalloonWhereInput[]
  contestId?: Prisma.IntFilter<"Balloon"> | number
  status?: Prisma.StringFilter<"Balloon"> | string
  assignedToId?: Prisma.StringNullableFilter<"Balloon"> | string | null
  createdAt?: Prisma.DateTimeFilter<"Balloon"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Balloon"> | Date | string
  submission?: Prisma.XOR<Prisma.SubmissionScalarRelationFilter, Prisma.SubmissionWhereInput>
  contest?: Prisma.XOR<Prisma.ContestScalarRelationFilter, Prisma.ContestWhereInput>
  assignedTo?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}, "id" | "submissionId">

export type BalloonOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  submissionId?: Prisma.SortOrder
  contestId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  assignedToId?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.BalloonCountOrderByAggregateInput
  _avg?: Prisma.BalloonAvgOrderByAggregateInput
  _max?: Prisma.BalloonMaxOrderByAggregateInput
  _min?: Prisma.BalloonMinOrderByAggregateInput
  _sum?: Prisma.BalloonSumOrderByAggregateInput
}

export type BalloonScalarWhereWithAggregatesInput = {
  AND?: Prisma.BalloonScalarWhereWithAggregatesInput | Prisma.BalloonScalarWhereWithAggregatesInput[]
  OR?: Prisma.BalloonScalarWhereWithAggregatesInput[]
  NOT?: Prisma.BalloonScalarWhereWithAggregatesInput | Prisma.BalloonScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"Balloon"> | number
  submissionId?: Prisma.StringWithAggregatesFilter<"Balloon"> | string
  contestId?: Prisma.IntWithAggregatesFilter<"Balloon"> | number
  status?: Prisma.StringWithAggregatesFilter<"Balloon"> | string
  assignedToId?: Prisma.StringNullableWithAggregatesFilter<"Balloon"> | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Balloon"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Balloon"> | Date | string
}

export type BalloonCreateInput = {
  status?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  submission: Prisma.SubmissionCreateNestedOneWithoutBalloonInput
  contest: Prisma.ContestCreateNestedOneWithoutBalloonsInput
  assignedTo?: Prisma.UserCreateNestedOneWithoutBalloonsInput
}

export type BalloonUncheckedCreateInput = {
  id?: number
  submissionId: string
  contestId: number
  status?: string
  assignedToId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type BalloonUpdateInput = {
  status?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  submission?: Prisma.SubmissionUpdateOneRequiredWithoutBalloonNestedInput
  contest?: Prisma.ContestUpdateOneRequiredWithoutBalloonsNestedInput
  assignedTo?: Prisma.UserUpdateOneWithoutBalloonsNestedInput
}

export type BalloonUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  submissionId?: Prisma.StringFieldUpdateOperationsInput | string
  contestId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.StringFieldUpdateOperationsInput | string
  assignedToId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BalloonCreateManyInput = {
  id?: number
  submissionId: string
  contestId: number
  status?: string
  assignedToId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type BalloonUpdateManyMutationInput = {
  status?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BalloonUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  submissionId?: Prisma.StringFieldUpdateOperationsInput | string
  contestId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.StringFieldUpdateOperationsInput | string
  assignedToId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BalloonListRelationFilter = {
  every?: Prisma.BalloonWhereInput
  some?: Prisma.BalloonWhereInput
  none?: Prisma.BalloonWhereInput
}

export type BalloonOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type BalloonCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  submissionId?: Prisma.SortOrder
  contestId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  assignedToId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type BalloonAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  contestId?: Prisma.SortOrder
}

export type BalloonMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  submissionId?: Prisma.SortOrder
  contestId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  assignedToId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type BalloonMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  submissionId?: Prisma.SortOrder
  contestId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  assignedToId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type BalloonSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  contestId?: Prisma.SortOrder
}

export type BalloonNullableScalarRelationFilter = {
  is?: Prisma.BalloonWhereInput | null
  isNot?: Prisma.BalloonWhereInput | null
}

export type BalloonCreateNestedManyWithoutAssignedToInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutAssignedToInput, Prisma.BalloonUncheckedCreateWithoutAssignedToInput> | Prisma.BalloonCreateWithoutAssignedToInput[] | Prisma.BalloonUncheckedCreateWithoutAssignedToInput[]
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutAssignedToInput | Prisma.BalloonCreateOrConnectWithoutAssignedToInput[]
  createMany?: Prisma.BalloonCreateManyAssignedToInputEnvelope
  connect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
}

export type BalloonUncheckedCreateNestedManyWithoutAssignedToInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutAssignedToInput, Prisma.BalloonUncheckedCreateWithoutAssignedToInput> | Prisma.BalloonCreateWithoutAssignedToInput[] | Prisma.BalloonUncheckedCreateWithoutAssignedToInput[]
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutAssignedToInput | Prisma.BalloonCreateOrConnectWithoutAssignedToInput[]
  createMany?: Prisma.BalloonCreateManyAssignedToInputEnvelope
  connect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
}

export type BalloonUpdateManyWithoutAssignedToNestedInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutAssignedToInput, Prisma.BalloonUncheckedCreateWithoutAssignedToInput> | Prisma.BalloonCreateWithoutAssignedToInput[] | Prisma.BalloonUncheckedCreateWithoutAssignedToInput[]
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutAssignedToInput | Prisma.BalloonCreateOrConnectWithoutAssignedToInput[]
  upsert?: Prisma.BalloonUpsertWithWhereUniqueWithoutAssignedToInput | Prisma.BalloonUpsertWithWhereUniqueWithoutAssignedToInput[]
  createMany?: Prisma.BalloonCreateManyAssignedToInputEnvelope
  set?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  disconnect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  delete?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  connect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  update?: Prisma.BalloonUpdateWithWhereUniqueWithoutAssignedToInput | Prisma.BalloonUpdateWithWhereUniqueWithoutAssignedToInput[]
  updateMany?: Prisma.BalloonUpdateManyWithWhereWithoutAssignedToInput | Prisma.BalloonUpdateManyWithWhereWithoutAssignedToInput[]
  deleteMany?: Prisma.BalloonScalarWhereInput | Prisma.BalloonScalarWhereInput[]
}

export type BalloonUncheckedUpdateManyWithoutAssignedToNestedInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutAssignedToInput, Prisma.BalloonUncheckedCreateWithoutAssignedToInput> | Prisma.BalloonCreateWithoutAssignedToInput[] | Prisma.BalloonUncheckedCreateWithoutAssignedToInput[]
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutAssignedToInput | Prisma.BalloonCreateOrConnectWithoutAssignedToInput[]
  upsert?: Prisma.BalloonUpsertWithWhereUniqueWithoutAssignedToInput | Prisma.BalloonUpsertWithWhereUniqueWithoutAssignedToInput[]
  createMany?: Prisma.BalloonCreateManyAssignedToInputEnvelope
  set?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  disconnect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  delete?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  connect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  update?: Prisma.BalloonUpdateWithWhereUniqueWithoutAssignedToInput | Prisma.BalloonUpdateWithWhereUniqueWithoutAssignedToInput[]
  updateMany?: Prisma.BalloonUpdateManyWithWhereWithoutAssignedToInput | Prisma.BalloonUpdateManyWithWhereWithoutAssignedToInput[]
  deleteMany?: Prisma.BalloonScalarWhereInput | Prisma.BalloonScalarWhereInput[]
}

export type BalloonCreateNestedManyWithoutContestInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutContestInput, Prisma.BalloonUncheckedCreateWithoutContestInput> | Prisma.BalloonCreateWithoutContestInput[] | Prisma.BalloonUncheckedCreateWithoutContestInput[]
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutContestInput | Prisma.BalloonCreateOrConnectWithoutContestInput[]
  createMany?: Prisma.BalloonCreateManyContestInputEnvelope
  connect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
}

export type BalloonUncheckedCreateNestedManyWithoutContestInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutContestInput, Prisma.BalloonUncheckedCreateWithoutContestInput> | Prisma.BalloonCreateWithoutContestInput[] | Prisma.BalloonUncheckedCreateWithoutContestInput[]
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutContestInput | Prisma.BalloonCreateOrConnectWithoutContestInput[]
  createMany?: Prisma.BalloonCreateManyContestInputEnvelope
  connect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
}

export type BalloonUpdateManyWithoutContestNestedInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutContestInput, Prisma.BalloonUncheckedCreateWithoutContestInput> | Prisma.BalloonCreateWithoutContestInput[] | Prisma.BalloonUncheckedCreateWithoutContestInput[]
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutContestInput | Prisma.BalloonCreateOrConnectWithoutContestInput[]
  upsert?: Prisma.BalloonUpsertWithWhereUniqueWithoutContestInput | Prisma.BalloonUpsertWithWhereUniqueWithoutContestInput[]
  createMany?: Prisma.BalloonCreateManyContestInputEnvelope
  set?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  disconnect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  delete?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  connect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  update?: Prisma.BalloonUpdateWithWhereUniqueWithoutContestInput | Prisma.BalloonUpdateWithWhereUniqueWithoutContestInput[]
  updateMany?: Prisma.BalloonUpdateManyWithWhereWithoutContestInput | Prisma.BalloonUpdateManyWithWhereWithoutContestInput[]
  deleteMany?: Prisma.BalloonScalarWhereInput | Prisma.BalloonScalarWhereInput[]
}

export type BalloonUncheckedUpdateManyWithoutContestNestedInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutContestInput, Prisma.BalloonUncheckedCreateWithoutContestInput> | Prisma.BalloonCreateWithoutContestInput[] | Prisma.BalloonUncheckedCreateWithoutContestInput[]
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutContestInput | Prisma.BalloonCreateOrConnectWithoutContestInput[]
  upsert?: Prisma.BalloonUpsertWithWhereUniqueWithoutContestInput | Prisma.BalloonUpsertWithWhereUniqueWithoutContestInput[]
  createMany?: Prisma.BalloonCreateManyContestInputEnvelope
  set?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  disconnect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  delete?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  connect?: Prisma.BalloonWhereUniqueInput | Prisma.BalloonWhereUniqueInput[]
  update?: Prisma.BalloonUpdateWithWhereUniqueWithoutContestInput | Prisma.BalloonUpdateWithWhereUniqueWithoutContestInput[]
  updateMany?: Prisma.BalloonUpdateManyWithWhereWithoutContestInput | Prisma.BalloonUpdateManyWithWhereWithoutContestInput[]
  deleteMany?: Prisma.BalloonScalarWhereInput | Prisma.BalloonScalarWhereInput[]
}

export type BalloonCreateNestedOneWithoutSubmissionInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutSubmissionInput, Prisma.BalloonUncheckedCreateWithoutSubmissionInput>
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutSubmissionInput
  connect?: Prisma.BalloonWhereUniqueInput
}

export type BalloonUncheckedCreateNestedOneWithoutSubmissionInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutSubmissionInput, Prisma.BalloonUncheckedCreateWithoutSubmissionInput>
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutSubmissionInput
  connect?: Prisma.BalloonWhereUniqueInput
}

export type BalloonUpdateOneWithoutSubmissionNestedInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutSubmissionInput, Prisma.BalloonUncheckedCreateWithoutSubmissionInput>
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutSubmissionInput
  upsert?: Prisma.BalloonUpsertWithoutSubmissionInput
  disconnect?: Prisma.BalloonWhereInput | boolean
  delete?: Prisma.BalloonWhereInput | boolean
  connect?: Prisma.BalloonWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.BalloonUpdateToOneWithWhereWithoutSubmissionInput, Prisma.BalloonUpdateWithoutSubmissionInput>, Prisma.BalloonUncheckedUpdateWithoutSubmissionInput>
}

export type BalloonUncheckedUpdateOneWithoutSubmissionNestedInput = {
  create?: Prisma.XOR<Prisma.BalloonCreateWithoutSubmissionInput, Prisma.BalloonUncheckedCreateWithoutSubmissionInput>
  connectOrCreate?: Prisma.BalloonCreateOrConnectWithoutSubmissionInput
  upsert?: Prisma.BalloonUpsertWithoutSubmissionInput
  disconnect?: Prisma.BalloonWhereInput | boolean
  delete?: Prisma.BalloonWhereInput | boolean
  connect?: Prisma.BalloonWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.BalloonUpdateToOneWithWhereWithoutSubmissionInput, Prisma.BalloonUpdateWithoutSubmissionInput>, Prisma.BalloonUncheckedUpdateWithoutSubmissionInput>
}

export type BalloonCreateWithoutAssignedToInput = {
  status?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  submission: Prisma.SubmissionCreateNestedOneWithoutBalloonInput
  contest: Prisma.ContestCreateNestedOneWithoutBalloonsInput
}

export type BalloonUncheckedCreateWithoutAssignedToInput = {
  id?: number
  submissionId: string
  contestId: number
  status?: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type BalloonCreateOrConnectWithoutAssignedToInput = {
  where: Prisma.BalloonWhereUniqueInput
  create: Prisma.XOR<Prisma.BalloonCreateWithoutAssignedToInput, Prisma.BalloonUncheckedCreateWithoutAssignedToInput>
}

export type BalloonCreateManyAssignedToInputEnvelope = {
  data: Prisma.BalloonCreateManyAssignedToInput | Prisma.BalloonCreateManyAssignedToInput[]
  skipDuplicates?: boolean
}

export type BalloonUpsertWithWhereUniqueWithoutAssignedToInput = {
  where: Prisma.BalloonWhereUniqueInput
  update: Prisma.XOR<Prisma.BalloonUpdateWithoutAssignedToInput, Prisma.BalloonUncheckedUpdateWithoutAssignedToInput>
  create: Prisma.XOR<Prisma.BalloonCreateWithoutAssignedToInput, Prisma.BalloonUncheckedCreateWithoutAssignedToInput>
}

export type BalloonUpdateWithWhereUniqueWithoutAssignedToInput = {
  where: Prisma.BalloonWhereUniqueInput
  data: Prisma.XOR<Prisma.BalloonUpdateWithoutAssignedToInput, Prisma.BalloonUncheckedUpdateWithoutAssignedToInput>
}

export type BalloonUpdateManyWithWhereWithoutAssignedToInput = {
  where: Prisma.BalloonScalarWhereInput
  data: Prisma.XOR<Prisma.BalloonUpdateManyMutationInput, Prisma.BalloonUncheckedUpdateManyWithoutAssignedToInput>
}

export type BalloonScalarWhereInput = {
  AND?: Prisma.BalloonScalarWhereInput | Prisma.BalloonScalarWhereInput[]
  OR?: Prisma.BalloonScalarWhereInput[]
  NOT?: Prisma.BalloonScalarWhereInput | Prisma.BalloonScalarWhereInput[]
  id?: Prisma.IntFilter<"Balloon"> | number
  submissionId?: Prisma.StringFilter<"Balloon"> | string
  contestId?: Prisma.IntFilter<"Balloon"> | number
  status?: Prisma.StringFilter<"Balloon"> | string
  assignedToId?: Prisma.StringNullableFilter<"Balloon"> | string | null
  createdAt?: Prisma.DateTimeFilter<"Balloon"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Balloon"> | Date | string
}

export type BalloonCreateWithoutContestInput = {
  status?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  submission: Prisma.SubmissionCreateNestedOneWithoutBalloonInput
  assignedTo?: Prisma.UserCreateNestedOneWithoutBalloonsInput
}

export type BalloonUncheckedCreateWithoutContestInput = {
  id?: number
  submissionId: string
  status?: string
  assignedToId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type BalloonCreateOrConnectWithoutContestInput = {
  where: Prisma.BalloonWhereUniqueInput
  create: Prisma.XOR<Prisma.BalloonCreateWithoutContestInput, Prisma.BalloonUncheckedCreateWithoutContestInput>
}

export type BalloonCreateManyContestInputEnvelope = {
  data: Prisma.BalloonCreateManyContestInput | Prisma.BalloonCreateManyContestInput[]
  skipDuplicates?: boolean
}

export type BalloonUpsertWithWhereUniqueWithoutContestInput = {
  where: Prisma.BalloonWhereUniqueInput
  update: Prisma.XOR<Prisma.BalloonUpdateWithoutContestInput, Prisma.BalloonUncheckedUpdateWithoutContestInput>
  create: Prisma.XOR<Prisma.BalloonCreateWithoutContestInput, Prisma.BalloonUncheckedCreateWithoutContestInput>
}

export type BalloonUpdateWithWhereUniqueWithoutContestInput = {
  where: Prisma.BalloonWhereUniqueInput
  data: Prisma.XOR<Prisma.BalloonUpdateWithoutContestInput, Prisma.BalloonUncheckedUpdateWithoutContestInput>
}

export type BalloonUpdateManyWithWhereWithoutContestInput = {
  where: Prisma.BalloonScalarWhereInput
  data: Prisma.XOR<Prisma.BalloonUpdateManyMutationInput, Prisma.BalloonUncheckedUpdateManyWithoutContestInput>
}

export type BalloonCreateWithoutSubmissionInput = {
  status?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  contest: Prisma.ContestCreateNestedOneWithoutBalloonsInput
  assignedTo?: Prisma.UserCreateNestedOneWithoutBalloonsInput
}

export type BalloonUncheckedCreateWithoutSubmissionInput = {
  id?: number
  contestId: number
  status?: string
  assignedToId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type BalloonCreateOrConnectWithoutSubmissionInput = {
  where: Prisma.BalloonWhereUniqueInput
  create: Prisma.XOR<Prisma.BalloonCreateWithoutSubmissionInput, Prisma.BalloonUncheckedCreateWithoutSubmissionInput>
}

export type BalloonUpsertWithoutSubmissionInput = {
  update: Prisma.XOR<Prisma.BalloonUpdateWithoutSubmissionInput, Prisma.BalloonUncheckedUpdateWithoutSubmissionInput>
  create: Prisma.XOR<Prisma.BalloonCreateWithoutSubmissionInput, Prisma.BalloonUncheckedCreateWithoutSubmissionInput>
  where?: Prisma.BalloonWhereInput
}

export type BalloonUpdateToOneWithWhereWithoutSubmissionInput = {
  where?: Prisma.BalloonWhereInput
  data: Prisma.XOR<Prisma.BalloonUpdateWithoutSubmissionInput, Prisma.BalloonUncheckedUpdateWithoutSubmissionInput>
}

export type BalloonUpdateWithoutSubmissionInput = {
  status?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  contest?: Prisma.ContestUpdateOneRequiredWithoutBalloonsNestedInput
  assignedTo?: Prisma.UserUpdateOneWithoutBalloonsNestedInput
}

export type BalloonUncheckedUpdateWithoutSubmissionInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  contestId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.StringFieldUpdateOperationsInput | string
  assignedToId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BalloonCreateManyAssignedToInput = {
  id?: number
  submissionId: string
  contestId: number
  status?: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type BalloonUpdateWithoutAssignedToInput = {
  status?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  submission?: Prisma.SubmissionUpdateOneRequiredWithoutBalloonNestedInput
  contest?: Prisma.ContestUpdateOneRequiredWithoutBalloonsNestedInput
}

export type BalloonUncheckedUpdateWithoutAssignedToInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  submissionId?: Prisma.StringFieldUpdateOperationsInput | string
  contestId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BalloonUncheckedUpdateManyWithoutAssignedToInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  submissionId?: Prisma.StringFieldUpdateOperationsInput | string
  contestId?: Prisma.IntFieldUpdateOperationsInput | number
  status?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BalloonCreateManyContestInput = {
  id?: number
  submissionId: string
  status?: string
  assignedToId?: string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type BalloonUpdateWithoutContestInput = {
  status?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  submission?: Prisma.SubmissionUpdateOneRequiredWithoutBalloonNestedInput
  assignedTo?: Prisma.UserUpdateOneWithoutBalloonsNestedInput
}

export type BalloonUncheckedUpdateWithoutContestInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  submissionId?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  assignedToId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BalloonUncheckedUpdateManyWithoutContestInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  submissionId?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.StringFieldUpdateOperationsInput | string
  assignedToId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type BalloonSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  submissionId?: boolean
  contestId?: boolean
  status?: boolean
  assignedToId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  submission?: boolean | Prisma.SubmissionDefaultArgs<ExtArgs>
  contest?: boolean | Prisma.ContestDefaultArgs<ExtArgs>
  assignedTo?: boolean | Prisma.Balloon$assignedToArgs<ExtArgs>
}, ExtArgs["result"]["balloon"]>

export type BalloonSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  submissionId?: boolean
  contestId?: boolean
  status?: boolean
  assignedToId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  submission?: boolean | Prisma.SubmissionDefaultArgs<ExtArgs>
  contest?: boolean | Prisma.ContestDefaultArgs<ExtArgs>
  assignedTo?: boolean | Prisma.Balloon$assignedToArgs<ExtArgs>
}, ExtArgs["result"]["balloon"]>

export type BalloonSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  submissionId?: boolean
  contestId?: boolean
  status?: boolean
  assignedToId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  submission?: boolean | Prisma.SubmissionDefaultArgs<ExtArgs>
  contest?: boolean | Prisma.ContestDefaultArgs<ExtArgs>
  assignedTo?: boolean | Prisma.Balloon$assignedToArgs<ExtArgs>
}, ExtArgs["result"]["balloon"]>

export type BalloonSelectScalar = {
  id?: boolean
  submissionId?: boolean
  contestId?: boolean
  status?: boolean
  assignedToId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type BalloonOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "submissionId" | "contestId" | "status" | "assignedToId" | "createdAt" | "updatedAt", ExtArgs["result"]["balloon"]>
export type BalloonInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  submission?: boolean | Prisma.SubmissionDefaultArgs<ExtArgs>
  contest?: boolean | Prisma.ContestDefaultArgs<ExtArgs>
  assignedTo?: boolean | Prisma.Balloon$assignedToArgs<ExtArgs>
}
export type BalloonIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  submission?: boolean | Prisma.SubmissionDefaultArgs<ExtArgs>
  contest?: boolean | Prisma.ContestDefaultArgs<ExtArgs>
  assignedTo?: boolean | Prisma.Balloon$assignedToArgs<ExtArgs>
}
export type BalloonIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  submission?: boolean | Prisma.SubmissionDefaultArgs<ExtArgs>
  contest?: boolean | Prisma.ContestDefaultArgs<ExtArgs>
  assignedTo?: boolean | Prisma.Balloon$assignedToArgs<ExtArgs>
}

export type $BalloonPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Balloon"
  objects: {
    submission: Prisma.$SubmissionPayload<ExtArgs>
    contest: Prisma.$ContestPayload<ExtArgs>
    assignedTo: Prisma.$UserPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    submissionId: string
    contestId: number
    status: string
    assignedToId: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["balloon"]>
  composites: {}
}

export type BalloonGetPayload<S extends boolean | null | undefined | BalloonDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$BalloonPayload, S>

export type BalloonCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<BalloonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: BalloonCountAggregateInputType | true
  }

export interface BalloonDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balloon'], meta: { name: 'Balloon' } }
  /**
   * Find zero or one Balloon that matches the filter.
   * @param {BalloonFindUniqueArgs} args - Arguments to find a Balloon
   * @example
   * // Get one Balloon
   * const balloon = await prisma.balloon.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends BalloonFindUniqueArgs>(args: Prisma.SelectSubset<T, BalloonFindUniqueArgs<ExtArgs>>): Prisma.Prisma__BalloonClient<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Balloon that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {BalloonFindUniqueOrThrowArgs} args - Arguments to find a Balloon
   * @example
   * // Get one Balloon
   * const balloon = await prisma.balloon.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends BalloonFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, BalloonFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__BalloonClient<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Balloon that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BalloonFindFirstArgs} args - Arguments to find a Balloon
   * @example
   * // Get one Balloon
   * const balloon = await prisma.balloon.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends BalloonFindFirstArgs>(args?: Prisma.SelectSubset<T, BalloonFindFirstArgs<ExtArgs>>): Prisma.Prisma__BalloonClient<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Balloon that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BalloonFindFirstOrThrowArgs} args - Arguments to find a Balloon
   * @example
   * // Get one Balloon
   * const balloon = await prisma.balloon.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends BalloonFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, BalloonFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__BalloonClient<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Balloons that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BalloonFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Balloons
   * const balloons = await prisma.balloon.findMany()
   * 
   * // Get first 10 Balloons
   * const balloons = await prisma.balloon.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const balloonWithIdOnly = await prisma.balloon.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends BalloonFindManyArgs>(args?: Prisma.SelectSubset<T, BalloonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Balloon.
   * @param {BalloonCreateArgs} args - Arguments to create a Balloon.
   * @example
   * // Create one Balloon
   * const Balloon = await prisma.balloon.create({
   *   data: {
   *     // ... data to create a Balloon
   *   }
   * })
   * 
   */
  create<T extends BalloonCreateArgs>(args: Prisma.SelectSubset<T, BalloonCreateArgs<ExtArgs>>): Prisma.Prisma__BalloonClient<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Balloons.
   * @param {BalloonCreateManyArgs} args - Arguments to create many Balloons.
   * @example
   * // Create many Balloons
   * const balloon = await prisma.balloon.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends BalloonCreateManyArgs>(args?: Prisma.SelectSubset<T, BalloonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Balloons and returns the data saved in the database.
   * @param {BalloonCreateManyAndReturnArgs} args - Arguments to create many Balloons.
   * @example
   * // Create many Balloons
   * const balloon = await prisma.balloon.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Balloons and only return the `id`
   * const balloonWithIdOnly = await prisma.balloon.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends BalloonCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, BalloonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Balloon.
   * @param {BalloonDeleteArgs} args - Arguments to delete one Balloon.
   * @example
   * // Delete one Balloon
   * const Balloon = await prisma.balloon.delete({
   *   where: {
   *     // ... filter to delete one Balloon
   *   }
   * })
   * 
   */
  delete<T extends BalloonDeleteArgs>(args: Prisma.SelectSubset<T, BalloonDeleteArgs<ExtArgs>>): Prisma.Prisma__BalloonClient<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Balloon.
   * @param {BalloonUpdateArgs} args - Arguments to update one Balloon.
   * @example
   * // Update one Balloon
   * const balloon = await prisma.balloon.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends BalloonUpdateArgs>(args: Prisma.SelectSubset<T, BalloonUpdateArgs<ExtArgs>>): Prisma.Prisma__BalloonClient<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Balloons.
   * @param {BalloonDeleteManyArgs} args - Arguments to filter Balloons to delete.
   * @example
   * // Delete a few Balloons
   * const { count } = await prisma.balloon.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends BalloonDeleteManyArgs>(args?: Prisma.SelectSubset<T, BalloonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Balloons.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BalloonUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Balloons
   * const balloon = await prisma.balloon.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends BalloonUpdateManyArgs>(args: Prisma.SelectSubset<T, BalloonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Balloons and returns the data updated in the database.
   * @param {BalloonUpdateManyAndReturnArgs} args - Arguments to update many Balloons.
   * @example
   * // Update many Balloons
   * const balloon = await prisma.balloon.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Balloons and only return the `id`
   * const balloonWithIdOnly = await prisma.balloon.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends BalloonUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, BalloonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Balloon.
   * @param {BalloonUpsertArgs} args - Arguments to update or create a Balloon.
   * @example
   * // Update or create a Balloon
   * const balloon = await prisma.balloon.upsert({
   *   create: {
   *     // ... data to create a Balloon
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Balloon we want to update
   *   }
   * })
   */
  upsert<T extends BalloonUpsertArgs>(args: Prisma.SelectSubset<T, BalloonUpsertArgs<ExtArgs>>): Prisma.Prisma__BalloonClient<runtime.Types.Result.GetResult<Prisma.$BalloonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Balloons.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BalloonCountArgs} args - Arguments to filter Balloons to count.
   * @example
   * // Count the number of Balloons
   * const count = await prisma.balloon.count({
   *   where: {
   *     // ... the filter for the Balloons we want to count
   *   }
   * })
  **/
  count<T extends BalloonCountArgs>(
    args?: Prisma.Subset<T, BalloonCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], BalloonCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Balloon.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BalloonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends BalloonAggregateArgs>(args: Prisma.Subset<T, BalloonAggregateArgs>): Prisma.PrismaPromise<GetBalloonAggregateType<T>>

  /**
   * Group by Balloon.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BalloonGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends BalloonGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: BalloonGroupByArgs['orderBy'] }
      : { orderBy?: BalloonGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, BalloonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalloonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Balloon model
 */
readonly fields: BalloonFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Balloon.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__BalloonClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  submission<T extends Prisma.SubmissionDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.SubmissionDefaultArgs<ExtArgs>>): Prisma.Prisma__SubmissionClient<runtime.Types.Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  contest<T extends Prisma.ContestDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ContestDefaultArgs<ExtArgs>>): Prisma.Prisma__ContestClient<runtime.Types.Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  assignedTo<T extends Prisma.Balloon$assignedToArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Balloon$assignedToArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Balloon model
 */
export interface BalloonFieldRefs {
  readonly id: Prisma.FieldRef<"Balloon", 'Int'>
  readonly submissionId: Prisma.FieldRef<"Balloon", 'String'>
  readonly contestId: Prisma.FieldRef<"Balloon", 'Int'>
  readonly status: Prisma.FieldRef<"Balloon", 'String'>
  readonly assignedToId: Prisma.FieldRef<"Balloon", 'String'>
  readonly createdAt: Prisma.FieldRef<"Balloon", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"Balloon", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Balloon findUnique
 */
export type BalloonFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * Filter, which Balloon to fetch.
   */
  where: Prisma.BalloonWhereUniqueInput
}

/**
 * Balloon findUniqueOrThrow
 */
export type BalloonFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * Filter, which Balloon to fetch.
   */
  where: Prisma.BalloonWhereUniqueInput
}

/**
 * Balloon findFirst
 */
export type BalloonFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * Filter, which Balloon to fetch.
   */
  where?: Prisma.BalloonWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Balloons to fetch.
   */
  orderBy?: Prisma.BalloonOrderByWithRelationInput | Prisma.BalloonOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Balloons.
   */
  cursor?: Prisma.BalloonWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Balloons from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Balloons.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Balloons.
   */
  distinct?: Prisma.BalloonScalarFieldEnum | Prisma.BalloonScalarFieldEnum[]
}

/**
 * Balloon findFirstOrThrow
 */
export type BalloonFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * Filter, which Balloon to fetch.
   */
  where?: Prisma.BalloonWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Balloons to fetch.
   */
  orderBy?: Prisma.BalloonOrderByWithRelationInput | Prisma.BalloonOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Balloons.
   */
  cursor?: Prisma.BalloonWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Balloons from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Balloons.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Balloons.
   */
  distinct?: Prisma.BalloonScalarFieldEnum | Prisma.BalloonScalarFieldEnum[]
}

/**
 * Balloon findMany
 */
export type BalloonFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * Filter, which Balloons to fetch.
   */
  where?: Prisma.BalloonWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Balloons to fetch.
   */
  orderBy?: Prisma.BalloonOrderByWithRelationInput | Prisma.BalloonOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Balloons.
   */
  cursor?: Prisma.BalloonWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Balloons from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Balloons.
   */
  skip?: number
  distinct?: Prisma.BalloonScalarFieldEnum | Prisma.BalloonScalarFieldEnum[]
}

/**
 * Balloon create
 */
export type BalloonCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * The data needed to create a Balloon.
   */
  data: Prisma.XOR<Prisma.BalloonCreateInput, Prisma.BalloonUncheckedCreateInput>
}

/**
 * Balloon createMany
 */
export type BalloonCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Balloons.
   */
  data: Prisma.BalloonCreateManyInput | Prisma.BalloonCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Balloon createManyAndReturn
 */
export type BalloonCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * The data used to create many Balloons.
   */
  data: Prisma.BalloonCreateManyInput | Prisma.BalloonCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Balloon update
 */
export type BalloonUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * The data needed to update a Balloon.
   */
  data: Prisma.XOR<Prisma.BalloonUpdateInput, Prisma.BalloonUncheckedUpdateInput>
  /**
   * Choose, which Balloon to update.
   */
  where: Prisma.BalloonWhereUniqueInput
}

/**
 * Balloon updateMany
 */
export type BalloonUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Balloons.
   */
  data: Prisma.XOR<Prisma.BalloonUpdateManyMutationInput, Prisma.BalloonUncheckedUpdateManyInput>
  /**
   * Filter which Balloons to update
   */
  where?: Prisma.BalloonWhereInput
  /**
   * Limit how many Balloons to update.
   */
  limit?: number
}

/**
 * Balloon updateManyAndReturn
 */
export type BalloonUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * The data used to update Balloons.
   */
  data: Prisma.XOR<Prisma.BalloonUpdateManyMutationInput, Prisma.BalloonUncheckedUpdateManyInput>
  /**
   * Filter which Balloons to update
   */
  where?: Prisma.BalloonWhereInput
  /**
   * Limit how many Balloons to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Balloon upsert
 */
export type BalloonUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * The filter to search for the Balloon to update in case it exists.
   */
  where: Prisma.BalloonWhereUniqueInput
  /**
   * In case the Balloon found by the `where` argument doesn't exist, create a new Balloon with this data.
   */
  create: Prisma.XOR<Prisma.BalloonCreateInput, Prisma.BalloonUncheckedCreateInput>
  /**
   * In case the Balloon was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.BalloonUpdateInput, Prisma.BalloonUncheckedUpdateInput>
}

/**
 * Balloon delete
 */
export type BalloonDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
  /**
   * Filter which Balloon to delete.
   */
  where: Prisma.BalloonWhereUniqueInput
}

/**
 * Balloon deleteMany
 */
export type BalloonDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Balloons to delete
   */
  where?: Prisma.BalloonWhereInput
  /**
   * Limit how many Balloons to delete.
   */
  limit?: number
}

/**
 * Balloon.assignedTo
 */
export type Balloon$assignedToArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  where?: Prisma.UserWhereInput
}

/**
 * Balloon without action
 */
export type BalloonDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Balloon
   */
  select?: Prisma.BalloonSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Balloon
   */
  omit?: Prisma.BalloonOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BalloonInclude<ExtArgs> | null
}
